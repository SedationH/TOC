<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Project</title>
  </head>
  <style>
    section {
      height: 80vh;
    }
    h1 {
      height: 20vh;
    }
    h2 {
      height: 30vh;
    }
  </style>
  <body>
    <pre>
<strong style="font-size: 20px; color: skyblue;">ç®€å•è§£é‡Šä» dom => ğŸŒ² çš„å¤„ç†è¿‡ç¨‹</strong>
</pre>
    <pre>
æ•´ä½“ç»“æ„ä¸º (key)
1 (0)
- 2 (0-1)
- 2 (0-2)
- - 3 (0-3)
1 (1)
</pre
    >
    <article>
      <h1>This is the first H1</h1>
      <section>æˆ‘ä»¬æ¥è¯´ä¸€äº›å†…å®¹</section>
      <h2>first H1's H2</h2>
      <h2>second H2</h2>
      <h3>this is h3</h3>
      <section>
        Chrome's official site to help you stay up to date on
        everything Chrome related, build Extensions, publish on the
        Chrome Web Store, optimize your website, and more.
      </section>
      <h1>second H1</h1>
      <section>æ¢ä¸€äº›å†…å®¹</section>
    </article>

    <script>
      /**
       * ç›®çš„ å½¢æˆ
       * [
       *  {
       *    xxx,
       *    children: [
       *      {
       *         xxx
       *      }
       *    ]
       *  }
       * çš„å±‚çº§åµŒå¥—ç»“æ„
       * ]
       */
      const options = {
        headingSelector: 'h1,h2,h3',
        contentSelector: 'article',
      }

      function getHeadings(options) {
        const headings = document
          .querySelector(options.contentSelector)
          .querySelectorAll(options.headingSelector)
        return headings
      }

      function getHeadingObject(heading) {
        const type = heading.tagName

        return {
          el: heading,
          type,
          children: [],
          key: '',
        }
      }

      // å‘ nestedHeadings åŠ å…¥ headingObject
      // è¦èƒ½åŠ å…¥åº”è¯¥å¤„äºçš„ä½ç½®
      function addNode(nestedHeadings, headingObject) {
        const key = []
        let children = nestedHeadings
        let index = children.length - 1
        key.push(index)
        let lastHeadingObject = children[index]
        // å®šä½åˆ°æ‰€åœ¨å±‚ æ‹¿åˆ°ç›¸åº”çš„children
        while (
          lastHeadingObject &&
          lastHeadingObject.type !== headingObject.type
        ) {
          // å¯»æ‰¾ä¸‹ä¸€å±‚
          children = lastHeadingObject.children
          index = children.length - 1
          key.push(index)
          lastHeadingObject = children[index]
        }
        // è·³å‡ºå¾ªç¯çš„æ—¶å€™
        //  1. lastHeadingObject === undefined
        //  2. lastHeadingObject.type === headingObject.type

        // keyçš„æœ€åä¸€ä¸ªæ˜¯è¦åŠ å…¥çš„ä½ç½®
        key[key.length - 1]++
        headingObject.key = key.join('-')
        children.push(headingObject)
        return nestedHeadings
      }

      function getNestedHeadings(headings) {
        headings = Array.from(headings)
        return headings.reduce((prev, heading) => {
          const headingObject = getHeadingObject(heading)
          return addNode(prev, headingObject)
        }, [])
      }

      const headings = getHeadings(options)
      const nestedHeadings = getNestedHeadings(headings)

      function iterateNestedHeadings(nestedHeadings, cb) {
        for (const headingObject of nestedHeadings) {
          cb(headingObject)
          const { children } = headingObject
          if (children.length) {
            iterateNestedHeadings(children, cb)
          }
        }
      }

      function getHeadingObserver(nestedHeadings, cb1, cb2) {
        const headingObserve = new IntersectionObserver(
          entries => {
            entries.forEach(entry => {
              if (entry.isIntersecting) {
                cb1 && cb1(entry)
              } else {
                cb2 && cb2(entry)
              }
            })
          },
          {
            rootMargin: '0px 0px -95% 0px',
          }
        )

        iterateNestedHeadings(nestedHeadings, handle)

        return headingObserver

        function handle(headingObject) {
          headingObserve.observe(headingObject.el)
        }
      }

      getHeadingObserver(
        nestedHeadings,
        e => console.log(1, e),
        e => console.log(2, e)
      )
    </script>
  </body>
</html>
